"""
Author: Tzuchen Liu
Supervisor: Faras Brumand
Master Thesis
This script offers different ways of analyzing the latent values:
statistics_each_dim:
    Calculate statistics of each dimension individually.
statistics_mean_of_dims:
    Calculate mean of statistics of each dimension individually.
compare_between_labels:
    Compare the latent values between different categories of data.
compare_between_phases:
    Compare the latent values between different segments of data.
compare_between_dimensions_same_labels:
    Compare the latent values of different latent dimentions.
two_dimensional_analysis_with_same_labels:
    Plot the latent values of two different latent dimentions.
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import skew, kurtosis
import numpy as np
import torch
from app.machine_learning.ae import AutoencoderIndividualWindow
from app.helper_func.config import VisualizationConfig, AEConfig
from app.helper_func.utils import slice_seq_to_windows


def statistics_each_dim(input_dataframe: pd.DataFrame, label_column_name: str,
                        output_filename: str,
                        invisible_xticks=False) -> pd.DataFrame:
    """
    Calculate mean, std, min, max, skew, and kurtosis of each dimension of the
    latent dataset.
    The latent dataset is generated by the function
     preprocess_for_training_classifiers in app/preprocessing.py
    This function returns the above mentioned calculateion results as well as
    saving the violinplot of each dimension to the output_filename.
    The files that end in '_violinplot_each_dim.pdf' in the app/assets/images
    are plotted by this function.
    """
    columns = [x for x in input_dataframe.columns if x != label_column_name]
    fig_ax = plt.subplot()
    fig_ax.violinplot(dataset=[input_dataframe[x] for x in columns])
    fig_ax.set_xticks(np.arange(1, len(columns) + 1))
    if invisible_xticks:
        fig_ax.set_xticklabels([])
    else:
        fig_ax.set_xticklabels(columns)
    plt.xlabel('Dimension', fontsize=16)
    plt.grid()
    plt.savefig(output_filename)
    plt.close()

    mean_each_dim = pd.DataFrame(
        np.mean(input_dataframe[columns]).values.reshape(1, -1))
    std_each_dim = pd.DataFrame(
        np.std(input_dataframe[columns]).values.reshape(1, -1))
    min_each_dim = pd.DataFrame(
        np.min(input_dataframe[columns]).values.reshape(1, -1))
    max_each_dim = pd.DataFrame(
        np.max(input_dataframe[columns]).values.reshape(1, -1))
    skew_each_dim = pd.DataFrame(
        skew(input_dataframe[columns]).reshape(1, -1))
    kurtosis_each_dim = pd.DataFrame(
        kurtosis(input_dataframe[columns]).reshape(1, -1))
    return_df = pd.concat([mean_each_dim, std_each_dim, min_each_dim,
                           max_each_dim,
                           skew_each_dim, kurtosis_each_dim])
    return_df.index = ['mean', 'std', 'min', 'max', 'skew', 'kurtosis']
    return return_df


def statistics_mean_of_dims(input_dataframe: pd.DataFrame,
                            label_column_name: str,
                            output_filename: str) -> pd.DataFrame:
    """
    Calculate mean of each row of the data.
    One row represent one latent datapoint,
    each column represent different dimension.
    The latent dataset is generated by the function
     preprocess_for_training_classifiers in app/preprocessing.py
    This function returns the mean, std, min, max, skew, and kurtosis of above
    calculated mean of all dimensions. This function also saves the violinplot
    of the mean of all dimensions to the output_filename.
    The files that end in '_violinplot_mean_dims.pdf' in the app/assets/images
    are plotted by this function.
    """
    columns = [x for x in input_dataframe.columns if x != label_column_name]
    mean_of_dims = input_dataframe.iloc[:, np.arange(
        len(columns))].mean(axis=1)
    fig_ax = plt.subplot()
    fig_ax.violinplot(dataset=mean_of_dims)
    fig_ax.set_xticklabels([])
    plt.grid()
    plt.savefig(output_filename)
    plt.close()

    return_df = pd.DataFrame([np.mean(mean_of_dims), np.std(mean_of_dims),
                              np.min(mean_of_dims), np.max(mean_of_dims),
                              skew(mean_of_dims), kurtosis(mean_of_dims)])
    return_df.index = ['mean', 'std', 'min', 'max', 'skew', 'kurtosis']
    return return_df


def compare_between_labels(input_dataframe: pd.DataFrame,
                           label_column_name: str,
                           output_filename: str):
    """
    Compare the violin plot between different categories of data
     e.g. different leakage type
    The latent dataset is generated by the function
     preprocess_for_training_classifiers in app/preprocessing.py
    The files that end in '_violinplot_comparison.pdf' in the app/assets/images
    are plotted by this function.
    """
    fontsize = 16
    columns = [x for x in input_dataframe.columns if x != label_column_name]
    labels = sorted(input_dataframe[label_column_name].unique())
    input_dataframe['mean'] = input_dataframe.iloc[:, np.arange(
        len(columns))].mean(axis=1)
    fig_ax = plt.subplot()
    fig_ax.violinplot(
        dataset=[input_dataframe['mean']] +
                [input_dataframe['mean'][
                    input_dataframe[label_column_name] == x] for x in labels])
    fig_ax.set_xticks(np.arange(1, len(labels) + 2))
    fig_ax.set_xticklabels(['ALL', '1', '2', '3', '4'])
    plt.xlabel('Leakage Category', fontsize=fontsize)
    # plt.show()
    plt.grid()
    plt.savefig(output_filename)
    plt.close()


def compare_between_phases(model_dir: str, output_dir: str,
                           model_list: list, data_path: str):
    """
    Compare the violin plot between different phase of data
     e.g. cylinder displacement rising, holding, decreasing
    The files that start in 'phase_latent_comparison_' in the app/assets/images
    are plotted by this function.

    first manual inspect and label the phases:
        windows = slice_seq_to_windows(
            torch.tensor(input_dataframe['x'].values), 200, 20, True)
        for window_count in range(75, 86):
        plt.plot(windows[window_count])
        plt.suptitle(str(window_count))
        plt.show()
    for dataset_5000.csv, window_id 20 and 21 are transition point from rising
    to flat, and 80 is the point from flat to decreasing
    """
    fontsize = 16

    increase_end_index = 20
    hold_start_index = 22
    hold_end_index = 80
    decrease_start_index = 81

    visual_config = VisualizationConfig()
    ae_config = AEConfig()
    for model_name in model_list:
        print(model_name)
        model_name_split = model_name.split('_')
        ae_config.model_type = model_name_split[0].lower()
        ae_config.latent_dim = int(model_name_split[2][1:])
        if model_name_split[1] == 'F2':
            ae_config.n_features = 2
            usecols = ['x', 'valve_status']
        else:
            ae_config.n_features = 3
            usecols = ['x', 'valve_status', 'velocity']

        ae_config.update()
        ae_model = AutoencoderIndividualWindow(ae_config=ae_config)
        state_dict = torch.load(model_dir + 'AE_' + model_name + '.pth')
        ae_model.load_state_dict(state_dict)

        data = torch.tensor(pd.read_csv(data_path, usecols=usecols).values)

        original_windows = torch.stack(slice_seq_to_windows(
            data, visual_config.window_length,
            visual_config.window_overlap_length,
            visual_config.irregular_window_at_end))

        with torch.no_grad():
            ae_model.eval()
            _, latent_mean = ae_model(original_windows)

            averaged_latent_mean = torch.mean(latent_mean, dim=1)

            latent_mean_increase = averaged_latent_mean[:increase_end_index]
            latent_mean_hold = \
                averaged_latent_mean[hold_start_index:hold_end_index]
            latent_mean_decrease = averaged_latent_mean[decrease_start_index:]
            latent_mean_all = torch.cat([latent_mean_increase,
                                         latent_mean_hold,
                                         latent_mean_decrease])

            fig_ax = plt.subplot()
            fig_ax.violinplot(dataset=[latent_mean_all, latent_mean_increase,
                                       latent_mean_hold, latent_mean_decrease])
            fig_ax.set_xticks(np.arange(1, 5))
            fig_ax.set_xticklabels(
                ['ALL', 'Increasing', 'Holding', 'Decreasing'])
            plt.xlabel('Phase', fontsize=fontsize)
            plt.ylabel('Value', fontsize=fontsize)
            # plt.show()
            plt.grid()
            plt.savefig(
                output_dir + 'phase_latent_comparison_%s.pdf' % model_name,
                bbox_inches='tight')
            plt.close()


def compare_between_dimensions_same_labels(input_dataframe: pd.DataFrame,
                                           label_column_name: str,
                                           output_filename_template: str):
    """
    Compare the violin plot of latent values between different latent
    dimensions.
    The latent dataset is generated by the function
     preprocess_for_training_classifiers in app/preprocessing.py
    The files that have '_dimension_comparison_leakage_' in the name and locate
    in the app/assets/images are plotted by this function.
    """
    fontsize = 16
    columns = [x for x in input_dataframe.columns if x != label_column_name]
    labels = sorted(input_dataframe[label_column_name].unique())
    for label_category, each_label in enumerate(labels):
        fig_ax = plt.subplot()
        fig_ax.violinplot([
            input_dataframe[col][
                input_dataframe[label_column_name] == each_label]
            for col in columns])
        fig_ax.set_xticks(np.arange(1, len(columns) + 1))
        fig_ax.set_xticklabels(columns, fontsize=fontsize)
        fig_ax.set_ylabel('Latent Value', fontsize=fontsize)
        fig_ax.yaxis.set_tick_params(labelsize=fontsize)
        plt.xlabel('Latent Dimension', fontsize=fontsize)
        # plt.show()
        plt.grid()
        output_filename = output_filename_template.replace(
            '*', str(label_category + 1))
        plt.savefig(output_filename)
        plt.close()


def two_dimensional_analysis_with_same_labels(input_dataframe: pd.DataFrame,
                                              label_column_name: str,
                                              output_filename: str,
                                              chosen_column1: str,
                                              chosen_column2: str):
    """
    To plot the latent values in a two dimensional figure.
    Two columns (two dimensions) are chosen (chosen_column1, chosen_column2)
    these two columns will be the x and y axis of the plot.
    The latent dataset is generated by the function
     preprocess_for_training_classifiers in app/preprocessing.py
    The files that have '_two_dimensional_comparison_' in the name and locate
    in the app/assets/images are plotted by this function.
    """
    labels = sorted(input_dataframe[label_column_name].unique())
    for label_category, each_label in enumerate(labels):
        plt.scatter(
            input_dataframe[chosen_column1][
                input_dataframe[label_column_name] == each_label],
            input_dataframe[chosen_column2][
                input_dataframe[label_column_name] == each_label],
            label='Leakage %s' % str(label_category + 1), alpha=0.5)
    plt.xlabel('Latent Dimension %s' % chosen_column1, fontsize=16)
    plt.ylabel('Latent Dimension %s' % chosen_column2, fontsize=16)
    plt.legend()
    # plt.show()
    plt.grid()
    plt.savefig(output_filename)
    plt.close()


if __name__ == '__main__':
    DO_COMPARE_BETWEEN_PHASES = True
    DO_COMPARE_BETWEEN_LABELS = False
    DO_COMPARE_BETWEEN_DIMENSIONS_SAME_LABELS = False
    DO_TWO_DIMENSIONAL_ANALYSIS_WITH_SAME_LABELS = False
    DO_STATISTICS_MEAN_OF_DIMS = False
    DO_STATISTICS_EACH_DIM = False

    MODEL_LIST = ['Linear_F2_L2', 'Linear_F2_L4', 'Linear_F2_L64',
                  'Linear_F3_L3', 'Linear_F3_L4', 'Linear_F3_L64',
                  'LSTM_F2_L2', 'LSTM_F2_L4', 'LSTM_F2_L64',
                  'LSTM_F3_L3', 'LSTM_F3_L4', 'LSTM_F3_L64']
    LOSS_DIR = '/home/tzuchen/Master_Thesis/Data/AE/'
    MODEL_DIR = '/home/tzuchen/Master_Thesis/Data/Models/'
    DATA_PATH = \
        '/home/tzuchen/Master_Thesis/Data/dataset_sequences/dataset_5000.csv'
    OUTPUT_DIR = '/home/tzuchen/Master_Thesis/Data/Plots/'
    LATENT_DIR = '/home/tzuchen/Master_Thesis/Data/dataset_classification/'
    STATISTICS_MEAN_OF_DIMS_PATH = '/home/tzuchen/Master_Thesis/Data/' \
                                   'Statistics/statistics_mean_of_dims.csv'

    # Latent of all windows
    ALL_DATASET_LIST = os.listdir(LATENT_DIR)
    ALL_DATASET_LIST = sorted(ALL_DATASET_LIST)
    ALL_STATISTICS_MEAN_OF_DIMS = pd.DataFrame()
    for dataset in ALL_DATASET_LIST:
        print('\n', dataset)

        df = pd.read_csv(LATENT_DIR + dataset)

        if DO_STATISTICS_EACH_DIM:
            if '_64latent' in dataset:
                continue
            statistics_each_dim(
                df, 'label',
                OUTPUT_DIR + dataset.replace(
                    '.csv', '_violinplot_each_dim.pdf'))

        if DO_STATISTICS_MEAN_OF_DIMS:
            statistics = statistics_mean_of_dims(
                df, 'label',
                OUTPUT_DIR + dataset.replace(
                    '.csv', '_violinplot_mean_dims.pdf'))
            statistics.columns = [dataset.replace('.csv', '')]
            if ALL_STATISTICS_MEAN_OF_DIMS.empty:
                ALL_STATISTICS_MEAN_OF_DIMS = statistics
            else:
                ALL_STATISTICS_MEAN_OF_DIMS = pd.concat(
                    [ALL_STATISTICS_MEAN_OF_DIMS, statistics], axis=1)

        if DO_COMPARE_BETWEEN_LABELS:
            compare_between_labels(df, 'label', OUTPUT_DIR + dataset.replace(
                '.csv', '_violinplot_comparison.pdf'))
        if DO_COMPARE_BETWEEN_DIMENSIONS_SAME_LABELS:
            if '_4latent' in dataset or '_3latent' in dataset:
                compare_between_dimensions_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_dimension_comparison_leakage_*.pdf'))
        if DO_TWO_DIMENSIONAL_ANALYSIS_WITH_SAME_LABELS:
            if 'each_window' in dataset:
                continue
            if '_4latent' in dataset or '_3latent' in dataset:
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim0_dim1.pdf'),
                    chosen_column1='0', chosen_column2='1')
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim0_dim2.pdf'),
                    chosen_column1='0', chosen_column2='2')
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim1_dim2.pdf'),
                    chosen_column1='1', chosen_column2='2')
            if '_4latent' in dataset:
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim0_dim3.pdf'),
                    chosen_column1='0', chosen_column2='3')
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim1_dim3.pdf'),
                    chosen_column1='1', chosen_column2='3')
                two_dimensional_analysis_with_same_labels(
                    df, 'label',
                    OUTPUT_DIR + dataset.replace(
                        '.csv', '_two_dimensional_comparison_dim2_dim3.pdf'),
                    chosen_column1='2', chosen_column2='3')

    if DO_COMPARE_BETWEEN_PHASES:
        compare_between_phases(MODEL_DIR, OUTPUT_DIR, MODEL_LIST, DATA_PATH)
    if DO_STATISTICS_MEAN_OF_DIMS:
        ALL_STATISTICS_MEAN_OF_DIMS.to_csv(STATISTICS_MEAN_OF_DIMS_PATH)
